#!/bin/bash

set -euo pipefail 

[[ -z ${DEBUG:+x} ]] || set -x

# BEGIN command functions

pasta_version() {
  local version="pasta 0.1"
  if which figlet >/dev/null
  then
    figlet "$version"
  else
    echo "$version"
  fi
}

# Usage: _pasta_usage COMMAND [full]
_pasta_usage() {
  local cmd="$1"
  local full
  [[ "${2:-}" == "full" ]] && full=true || full=false
  local prefix
  if $full
  then
    # Add spacing if the full usage is required.
    prefix="    ${PROGRAM}"
  else
    # Otherwise, this is for an error message.
    prefix="Usage: ${PROGRAM}"
  fi
  # Print short usages.
  case "$cmd" in
    init) echo "${prefix} init [PASTA_DIRECTORY]" ;;
    save) echo "${prefix} save [--force,-f] PASTA_NAME" ;;
    insert) echo "${prefix} insert [--force,-f] PASTA_NAME" ;;
    file) echo "${prefix} file [--force,-f] FILE PASTA_NAME" ;;
    load) echo "${prefix} [load] PASTA_NAME" ;;
    paste) echo "${prefix} paste [--force,-f] PASTA_NAME FILE" ;;
    inspect|show) echo "${prefix} inspect|show PASTA_NAME" ;;
    list|ls) echo "${prefix} [list|ls] [DIRECTORY]" ;;
    find) echo "${prefix} find PASTA_NAMES" ;;
    grep) echo "${prefix} grep SEARCH_STRING" ;;
    alias|ln) echo "${prefix} alias|ln [--verbose,-v] [--symbolic,-s] [--force,-f] PASTA_NAME PASTA_ALIAS" ;;
    cp) echo "${prefix} cp [--verbose,-v] [--recursive,-r] [--force,-f] SOURCE_PASTA DEST_PASTA" ;;
    rename|mv) echo "${prefix} rename|mv [--verbose,-v] [--force,-f] SOURCE_PASTA DEST_PASTA" ;;
    delete|remove|rm) echo "${prefix} delete|remove|rm [--recursive,-r] PASTA_NAMES" ;;
    edit) echo "${prefix} edit PASTA_NAME" ;;
    help|usage) echo "${prefix} help|usage" ;;
    version) echo "${prefix} version" ;;
    *) echoerr "Error: _pasta_usage received unknown command ${cmd}"; exit 1 ;;
  esac
  $full || return 0
  prefix="       "
  case "$cmd" in
    init)
      echo "${prefix} Initialize the copypasta storage."
      echo "${prefix} If DIRECTORY is not provided, it will be initialized to ~/.pastas."
      ;;
    save) echo "${prefix} Save the data on the clipboard as PASTA_NAME." ;;
    insert) echo "${prefix} Open a text editor to write a copypasta." ;;
    file) echo "${prefix} Save the file as PASTA_NAME." ;;
    load) echo "${prefix} Place the existing copypasta on the clipboard." ;;
    paste) echo "${prefix} Paste the copypasta to a file." ;;
    inspect|show) echo "${prefix} Show the copypasta." ;;
    list|ls) echo "${prefix} List copypastas." ;;
    find) echo "${prefix} List copypastas which match the pasta names." ;;
    grep) echo "${prefix} Search text copypastas which contain the search string." ;;
    alias|ln) echo "${prefix} Create a link to PASTA_NAME named PASTA_ALIAS." ;;
    cp) echo "${prefix} Create a copy of SOURCE_PASTA named DEST_PASTA." ;;
    rename|mv) echo "${prefix} Rename SOURCE_PASTA to DEST_PASTA." ;;
    delete|remove|rm) echo "${prefix} Delete the given copypasta(s)." ;;
    edit) echo "${prefix} Edit the copypasta." ;;
    help|usage) echo "${prefix} Display this help message." ;;
    version) echo "${prefix} Display version information." ;;
  esac
}

pasta_usage() {
  pasta_version
  echo
  echo "Usage:"
  for cmd in "init" "save" "insert" "file" "load" "paste" "inspect" "list" "find" "grep" "alias" "cp" "rename" "delete" "edit" "help" "version"
  do
    _pasta_usage "$cmd" full
  done
}

pasta_init() {
  [[ "$#" -le 1 ]] || usagequit init
  check_exists "$PASTA_SETTINGS" "A pasta directory"
  local pasta_dir="$HOME/.pastas"
  if [[ "$#" -eq 1 ]]
  then
    pasta_dir="$1"
  fi
  pasta_dir="$(realpath "$pasta_dir")"
  echo "$pasta_dir" >"$PASTA_SETTINGS"
  mkdir -p "$pasta_dir"
  echo Initialized the pasta directory at $pasta_dir.
}

pasta_save() {
  local force
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
    -*) flagquit "$1" ;;
  esac
  [[ "$#" -ge 1 ]] || usagequit save
  local pasta_name="$*"
  check_pasta_name "$pasta_name" write "${force:-}"
  local temp_file
  create_temp_file temp_file
  [[ -f "$temp_file" ]]
  if clipboard_is_image
  then
    $imgpaste > "$temp_file"
    create_pasta_from_file "$temp_file" image "$pasta_name"
  else
    $textpaste > "$temp_file" 2>/dev/null || quit "Error: the clipboard is empty"
    create_pasta_from_file "$temp_file" text "$pasta_name"
  fi
}

pasta_insert() {
  local force
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
    -*) flagquit "$1" ;;
  esac
  [[ "$#" -ge 1 ]] || usagequit insert
  local pasta_name="$*"
  check_pasta_name "$pasta_name" write "${force:-}"
  local temp_file
  create_temp_file temp_file
  # Remove the temporary file to detect a difference between exiting the
  # editor without doing anything and choosing to write an empty file
  rm "$temp_file"
  ${EDITOR:-vi} "$temp_file"
  [[ -f "$temp_file" ]] || userquit "Pasta not created."
  create_pasta_from_file "$temp_file" text "$pasta_name"
}

pasta_file() {
  local force
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
    -*) flagquit "$1" ;;
  esac
  [[ $# -ge 2 ]] || usagequit file
  local file="$1"
  local pasta_name="${*:2}"
  [[ -f "$file" ]] || { [[ -d "$file" ]] && quit "Error: ${file} is a directory"; } || quit "Error: no file '${file}' exists"
  check_pasta_name "$pasta_name" write "${force:-}"
  local mimetype="$(file --mime-type -b "$file")"
  local ftype="$(cut -d'/' -f1 <<< "$mimetype")"
  create_pasta_from_file "$file" "$ftype" "$pasta_name" "$mimetype"
}

pasta_load() {
  if [[ "$#" -eq 0 ]]
  then
    pasta_list
    return 0
  fi
  local pasta_name="$*"
  local pasta_type pasta_file
  check_pasta_name "$pasta_name" read pasta_type pasta_file
  pasta_load_file "$pasta_name" "$pasta_type" "$pasta_file"
}

pasta_load_file() {
  local pasta_name="$1"
  local pasta_type="$2"
  local pasta_file="$3"
  case "$pasta_type" in
    dir) pasta_list_dir "$pasta_file" "$pasta_name"; return 0 ;;
    text) $textcopy "$pasta_file" >/dev/null 2>&1 ;;
    image) $imgcopy "$pasta_file" >/dev/null 2>&1 ;;
    *) echoerr "Error: check_pasta_name returned unknown type ${pasta_type}"; exit 1 ;;
  esac
  echo "Loaded ${pasta_type} pasta '${pasta_name}' to the clipboard."
}

pasta_pastefile() {
  not_implemented
}

pasta_show() {
  if [[ "$#" -eq 0 ]]
  then
    pasta_list
    return 0
  fi
  local pasta_name="$*"
  local pasta_type pasta_file
  check_pasta_name "$pasta_name" read pasta_type pasta_file
  case "$pasta_type" in
    dir) pasta_list_dir "$pasta_file" "$pasta_name" ;;
    text) cat "$pasta_file" ;;
    image) $imgshow "$pasta_file" ;;
  esac
}

pasta_list() {
  get_pasta_dir
  local pasta_path="$*"
  [[ -z "$pasta_path" ]] || check_pasta_name_safety "$pasta_path"
  local full_path="${PASTA_DIR}/$pasta_path"
  pasta_list_dir "$full_path" "$pasta_path"
}

pasta_list_dir() {
  local full_path="$1"
  local pasta_name="$2"
  local pasta_path="$(realpath --relative-to="$PASTA_DIR" "$full_path")"
  if [[ -d "$full_path" ]]
  then
    [[ "$pasta_path" == "." ]] && echo "Pasta Store" || echo "$pasta_path"
  else
    local pasta_type pasta_file
    if check_name_exists "$pasta_path" check pasta_type pasta_file
    then
      [[ "$pasta_type" != "dir" ]] || echoerr "Error: check_name_exists returned dir in pasta_list" && exit 1
      pasta_load_file "$pasta_path" "$pasta_type" "$pasta_file"
      return 0
    else
      quit "Error: ${pasta_name} does not exist"
    fi
  fi

  # Output the tree, removing the root of the tree or the .txt or .png extension but keeping any
  # colors.  Note: this also removes the extension from directories which
  # end an extension, which is a bug. One way to possibly fix this is to
  # detect the color code for directories and check for that, or replace
  # tree with our own implementation.
  tree -C --noreport "$full_path" | tail -n +2 | sed -r 's/\.(txt|png)(\x1b\[00m)?$/\2/'
}

pasta_find() {
  not_implemented
}

pasta_grep() {
  not_implemented
}

pasta_move() {
  local force="" recursive="" verbose="" symbolic=""
  local cmd
  case "$COMMAND" in
    cp) cmd="cp" ;;
    rename|mv) cmd="mv" ;;
    alias|ln) cmd="ln" ;;
    *) echoerr "Unknown command 'pasta ${COMMAND}'"; exit 1 ;;
  esac
  while true
  do
    case "${1:-}" in
      -f|--force) force="-f" ;;
      -r|--recursive)
        [[ "$cmd" == "cp" ]] || flagquit "$1"
        recursive="-r"
        ;;
      -s|--symbolic)
        [[ "$cmd" == "ln" ]] || flagquit "$1"
        symbolic="-s"
        ;;
      -v|--verbose) verbose="-v" ;;
      --) shift; break ;;
      -*) flagquit "$1" ;;
      # Done with flags
      *) break ;;
    esac
    shift
  done
  [[ "$#" -ge 2 ]] || usagequit "$COMMAND"
  local source_pasta="$1"
  local dest_pasta="${*:2}"
  local source_type source_file
  check_pasta_name "$source_pasta" read source_type source_file
  if [[ "$source_type" == "dir" ]]
  then
    if [[ "$cmd" == "cp" ]] && [[ -z "$recursive" ]]
    then
      quit "Error: '${source_pasta}' is a directory. Please use the --recursive flag"
    elif [[ "$cmd" == "ln" ]] && [[ -z "$symbolic" ]]
    then
      quit "Error: '${source_pasta}' is a directory. Please use the --symbolic flag"
    fi
  fi
  local dest_file
  case "$source_type" in
    dir) dest_file="${PASTA_DIR}/$dest_pasta" ;;
    text) dest_file="${PASTA_DIR}/${dest_pasta}.txt" ;;
    image) dest_file="${PASTA_DIR}/${dest_pasta}.png" ;;
    *) echoerr "Error: check_pasta_name returned unknown type '${source_type}'"; exit 1 ;;
  esac
  local existing_dest_type existing_dest_file
  # Use the check mode instead of write in case the files are the same.
  if check_pasta_name "$dest_pasta" check existing_dest_type existing_dest_file
  then
    if [[ "$existing_dest_type" == "dir" ]]
    then
      [[ ! "$source_file" -ef "$existing_dest_file" ]] || quit "Error: cannot ${COMMAND} directory '${source_pasta}' into itself"
      # The destination file is a directory, but the ln, cp, or mv commands
      # will place the resulting pasta in that directory accordingly.
      dest_file="$existing_dest_file"
    elif [[ "$source_type" != "dir" ]]
    then
      [[ "$(realpath -sm "$source_file")" != "$(realpath -sm "$dest_file")" ]] || quit "Error: '${source_pasta}' and '${dest_pasta}' are the same pasta"
      [[ -n "$force" ]] || check_exists "$existing_dest_file" "$dest_pasta"
    fi
  fi
  ensure_parent_dirs "$dest_file"
  $cmd $symbolic $recursive $force $verbose "$source_file" "$dest_file"

  local formatted_source_type
  case "$source_type" in
    text|image) formatted_source_type="${source_type^} pasta" ;;
    dir) formatted_source_type="Directory" ;;
    *) echoerr "Error: check_pasta_name returned unknown type '${source_type}'"; exit 1 ;;
  esac
  local op
  case "$cmd" in
    ln) op="aliased" ;;
    cp) op="copied" ;;
    mv)
      remove_empty_ancestors "$source_file"
      op="renamed"
      ;;
  esac
  echo "${formatted_source_type} '${source_pasta}' ${op} to '${dest_pasta}'"
}

pasta_delete() {
  local recursive=""
  case "${1:-}" in
    -r|--recursive) shift; recursive="-r" ;;
    --) shift ;;
    -*) flagquit "$1" ;;
  esac
  [[ "$#" -ge 1 ]] || usagequit delete
  local pasta_name pasta_type pasta_file
  for pasta_name in "$@"
  do
    check_pasta_name "$pasta_name" read pasta_type pasta_file
    local desc
    case "$pasta_type" in
      text) desc="text pasta" ;;
      image) desc="image pasta" ;;
      dir)
        [[ -n "$recursive" ]] || quit "Error: '${pasta_name}' is a directory. Please use the --recursive flag"
        desc="directory"
        ;;
      *) echoerr "check_pasta_name returned unknown type '${pasta_type}'"; exit 1 ;;
    esac
    rm $recursive "$pasta_file"
    remove_empty_ancestors "$pasta_file"
    echo "Deleted ${desc} '${pasta_name}'"
  done
}

pasta_edit() {
  [[ "$#" -ge 1 ]] || usagequit edit
  local pasta_name="$*"
  local pasta_type pasta_file
  check_pasta_name "$pasta_name" read pasta_type pasta_file
  case "$pasta_type" in
    text) ;;
    image) quit "Error: cannot edit image pasta '${pasta_name}'. Please use your favorite image editing software on the file '${pasta_file}'" ;;
    dir) quit "Error: cannot edit directory '${pasta_name}'" ;;
    *) echoerr "Error: check_pasta_name returned unknown type '${pasta_type}'"; exit 1 ;;
  esac
  ${EDITOR:-vi} "$pasta_file"
  [[ -s "$pasta_file" ]] || rm "$pasta_file" && remove_empty_ancestors "$pasta_file" && echo "Deleted empty text pasta '${pasta_name}'"
}

# END command functions


# BEGIN helper functions

not_implemented() {
  quit "This functionality has not been implemented yet!"
}

echoerr() {
  echo "$@" >&2
}

# Exit with an error message.
quit() {
  echoerr "$@"
  exit 2
}

# Exit with the usage message.
# Usage: usagequit command
usagequit() {
  _pasta_usage "$1" >&2
  exit 2
}

# Exit with an error message about an unknown flag.
# Usage: argquit unknown_argument
flagquit() {
  quit "${PROGRAM} ${COMMAND}: unknown flag '${1}'"
}

# Exit with an error message but with the user-cancelled error code.
userquit() {
  echoerr "$@"
  exit 3
}

# Prompt the user for a yes or no question and exit if no.
yesno() {
  local answer
  read -r -p "$1 [yN] " answer
  [[ "$answer" == [yY] ]] || exit 3
}

get_pasta_dir() {
  [[ -f "$PASTA_SETTINGS" ]] || quit "Pasta has not been initialized. Please run:
  $PROGRAM init
before using pasta."
  PASTA_DIR="$(< "$PASTA_SETTINGS")"
  [[ -d "$PASTA_DIR" ]] || quit "Pasta has not been initialized properly. Please run:
  $PROGRAM init"
}

# Usage: check_exists FILE DESCRIPTION
check_exists() {
  [[ ! -f "$1" ]] || { yesno "$2 already exists. Overwrite it?"; rm "$1"; }
}

# Usage: check pasta_name_safety PASTA_NAME
check_pasta_name_safety() {
  local name="$1"
  [[ -n "$name" ]] || quit "Error: empty pasta name given"
  [[ "$name" != ".." ]] && [[ ! "$name" =~ ^"../" ]] && [[ ! "$name" =~ "/.."$ ]] && [[ ! "$name" =~ "/../" ]] || quit "${name} is an invalid pasta name, remove '..' from the name"
}

# Checks if a pasta already exists by name.
# Accepts 3 modes: check, read, and write.
# If read or check is given, it also takes 2 additional arguments TYPE_VAR
# and FILE_VAR, which are the names of the variable to assign the type of
# the pasta and the location of the pasta file. Read exits the program if no
# pasta file exists, while check just returns an error.
# If write is given, it asks the user if they want to overwrite the existing
# pasta, deleting it if they choose yes. However, if the "force" argument is
# given, the answer is assumed to be yes.
# Usage: check_name_exists PASTA_NAME (read|write|check) [ARGS...]
check_name_exists() {
  local pasta_name="$1"
  local operation="$2"
  local pasta_txt_file="${PASTA_DIR}/${pasta_name}.txt"
  local pasta_img_file="${PASTA_DIR}/${pasta_name}.png"
  local pasta_subdir="${PASTA_DIR}/${pasta_name}"
  case "$operation" in
    read|check)
      local type_var="$3"
      local file_var="$4"
      if [[ -f "$pasta_txt_file" ]]
      then
        read "$type_var" "$file_var" <<< "text $pasta_txt_file"
      elif [[ -f "$pasta_img_file" ]]
      then

        read "$type_var" "$file_var" <<< "image $pasta_img_file"
      elif [[ -d "$pasta_subdir" ]]
      then
        read "$type_var" "$file_var" <<< "dir $pasta_subdir"
      elif [[ "$operation" == "read" ]]
      then
        quit "Error: ${pasta_name} does not exist"
      else
        return 1
      fi
      ;;
    write)
      if [[ -f "$pasta_txt_file" ]] || [[ -f "$pasta_img_file" ]]
      then
        local force="$3"
        [[ "$force" == "force" ]] || yesno "${pasta_name} already exists. Overwrite it?"
        rm -f "$pasta_txt_file" "$pasta_img_file"
      fi
      ;;
    *)
      echoerr "check_name_exists called with invalid mode ${read_or_write}"
      exit 1
      ;;
  esac
}

# Boilerplate to verify that a pasta name is valid.
# Usage: check_pasta_name PASTA_NAME read_or_write OPTIONS
check_pasta_name() {
  local pasta_name="$1"
  get_pasta_dir
  check_pasta_name_safety "$pasta_name"
  check_name_exists "$pasta_name" "${@:2}"
}

# Succeeds if the data on the clipboard is an image.
clipboard_is_image() {
  [[ "$SYSTEM" =~ ^Linux ]] && [[ "$(xclip -sel clipboard -o -t TARGETS 2>/dev/null)" =~ image ]]
}

TEMP_FILES=()

# Creates a temp file and saves its name to the given variable.
# Usage: create_temp_file VARIABLE_NAME [EXTENSION]
create_temp_file() {
  local var_name="$1"
  local ext="${2:-}"
  local _temp_file="$(mktemp)"
  if [[ -n "$ext" ]]
  then
    mv "$_temp_file" "${_temp_file}.$ext"
    _temp_file="${_temp_file}.$ext"
  fi
  # Add the current file to the set of tempfiles to delete.
  # This is necessary because only one function can be trapped per signal.
  TEMP_FILES+=("$_temp_file")
  trap "rm -f ${TEMP_FILES[*]}" INT TERM EXIT
  read "$var_name" <<< "$_temp_file"
}

# Ensures the parent directories of a file exists.
# Usage: ensure_parent_dirs FILE
ensure_parent_dirs() {
  mkdir -p "$(dirname "$1")"
}

# Removes the empty directories above the given file up to the pasta
# directory.
# Usage: remove_empty_ancestors PASTA_FILE
remove_empty_ancestors() {
  # Get the path of the parent relative to the pasta directory so rmdir
  # doesn't remove the pasta directory.
  local parent="$(realpath --relative-to="$PASTA_DIR" "$(dirname "$1")")"
  # Run in a subshell to not change the parent's working directory, but only
  # if the parent isn't the pasta directory.
  [[ "$parent" == "." ]] || (cd "$PASTA_DIR" && rmdir --ignore-fail-on-non-empty -p "$parent")
}

# Creates a pasta file from an existing file.
# Usage: create_pasta_from_file FILE image_or_text PASTA_NAME [DETECTED_MIME_TYPE]
create_pasta_from_file() {
  local source_file="$1"
  local file_type="$2"
  local pasta_name="$3"
  local pasta_file="${PASTA_DIR}/${pasta_name}"
  # If a previous function already did the work to detect the file type, no need to detect it again.
  local detected_type="${4:-$(file --mime-type -b "$source_file")}"
  if [[ "$detected_type" == "inode/x-empty" ]]
  then
    quit "Error: ${source_file} is empty"
  elif [[ ! "$detected_type" =~ ^text ]] && [[ ! "$detected_type" =~ ^image ]]
  then
    quit "Error: unknown MIME type $detected_type"
  elif [[ ! "$detected_type" =~ ^"$file_type" ]]
  then
    echoerr "Error: given type ${file_type} does not match detected type ${detected_type}"
    exit 1
  fi
  case "$file_type" in
    image)
      pasta_file="${pasta_file}.png"
      # Convert to png if necessary.
      if [[ "$detected_type" != "image/png" ]]
      then
        local temp_png
        create_temp_file temp_png png
        convert "$source_file" "$temp_png"
        source_file="$temp_png"
      fi
      ;;
    text) pasta_file="${pasta_file}.txt" ;;
    # Default case should never be called.
    *) echoerr "Error: unknown declared file type $file_type"; exit 1 ;;
  esac
  # Ensure the parent directory exists.
  ensure_parent_dirs "$pasta_file"
  cp "$source_file" "$pasta_file"
  echo "Created ${file_type} pasta '${pasta_name}'"
}
# END helper functions

SYSTEM="$(uname -s)"
case "$SYSTEM" in
  Linux*)
    which xclip >/dev/null || quit "Could not find clipboard provider on this system"
    textcopy="xclip -selection clipboard -i"
    textpaste="xclip -selection clipboard -o"
    # Png data seems to work best for pasting into browsers.
    imgcopy="xclip -selection clipboard -t image/png -i"
    imgpaste="xclip -selection clipboard -t image/png -o"
    imgshow="xdg-open"
    ;;
  Darwin*)
    which pbcopy >/dev/null || which pbpaste >/dev/null || quit "Could not find clipboard provider on this system"
    textcopy="pbcopy"
    textpaste="pbpaste"
    imgcopy="quit 'Copying and pasting images is unsupported in MacOS at the moment'"
    imgpaste="quit 'Copying and pasting images is unsupported in MacOS at the moment'"
    imgshow="open"
    ;;
  *)
    quit "pasta is not supported on this system."
esac

PROGRAM="${0##*/}"
COMMAND="${1:-}"
PASTA_SETTINGS="${PASTA_SETTINGS:-"${HOME}/.pasta"}"

case "$COMMAND" in
  init) shift; pasta_init "$@" ;;
  save) shift; pasta_save "$@" ;;
  insert) shift; pasta_insert "$@" ;;
  file) shift; pasta_file "$@" ;;
  load) shift; pasta_load "$@" ;;
  paste) shift; pasta_pastefile "$@" ;;
  show|inspect) shift; pasta_show "$@" ;;
  list|ls) shift; pasta_list "$@" ;;
  find|search) shift; pasta_find "$@" ;;
  grep) shift; pasta_grep "$@" ;;
  alias|ln|cp|rename|mv) shift; pasta_move "$@" ;;
  delete|remove|rm) shift; pasta_delete "$@" ;;
  edit) shift; pasta_edit "$@" ;;
  help|--help|usage) shift; pasta_usage ;;
  version|--version) shift; pasta_version ;;
  *) pasta_load "$@" ;;
esac
exit 0
