#!/bin/bash

set -euo pipefail 

[[ -z ${DEBUG:+x} ]] || set -x

# BEGIN command functions

pasta_version() {
  local version="pasta 0.1"
  if which figlet >/dev/null
  then
    figlet "$version"
  else
    echo "$version"
  fi
}

pasta_usage() {
  pasta_version
  echo
  echo "Usage:
    $PROGRAM init [DIRECTORY]
        Initialize the copypasta storage.
        If DIRECTORY is not provided, it will be initialized to ~/.pastas.
    $PROGRAM save [--force,-f] PASTA_NAME
        Save the data on the clipboard as PASTA_NAME.
    $PROGRAM insert [--force,-f] PASTA_NAME
        Open a text editor to write a copypasta.
    $PROGRAM file [--force,-f] FILE PASTA_NAME
        Save the file as PASTA_NAME.
    $PROGRAM [load] PASTA_NAME
        Place the existing copypasta on the clipboard.
    $PROGRAM paste [--force,-f] PASTA_NAME FILE
        Paste the copypasta to a file.
    $PROGRAM inspect|show PASTA_NAME
        Show the copypasta.
    $PROGRAM [list|ls] [DIRECTORY]
        List copypastas.
    $PROGRAM find PASTA_NAMES
        List copypastas which match the pasta names.
    $PROGRAM grep SEARCH_STRING
        Search copypastas which contain the search string.
    $PROGRAM alias|ln [--symbolic,-s] [--force,-f] PASTA_1 PASTA_2
        Create a link to PASTA_1 named PASTA_2.
    $PROGRAM cp [--force,-f] PASTA_1 PASTA_2
        Create a copy of PASTA_1 named PASTA_2.
    $PROGRAM rename|mv [--force,-f] PASTA_1 PASTA_2
        Rename PASTA_1 to PASTA_2
    $PROGRAM delete|remove|rm [--recursive,-r] PASTA_NAME
        Delete the copypasta.
    $PROGRAM edit PASTA_NAME
        Edit the copypasta.
    $PROGRAM help|usage
        Display this help message.
    $PROGRAM version
        Display version information."
}

pasta_init() {
  [[ "$#" -le 1 ]] || quit "Usage: $PROGRAM init [PASTA_DIRECTORY]"
  check_exists "$PASTA_SETTINGS" "A pasta directory"
  local pasta_dir="$HOME/.pastas"
  if [[ "$#" -eq 1 ]]
  then
    pasta_dir="$1"
  fi
  pasta_dir="$(realpath "$pasta_dir")"
  echo "$pasta_dir" >"$PASTA_SETTINGS"
  mkdir -p "$pasta_dir"
  echo Initialized the pasta directory at $pasta_dir.
}

pasta_save() {
  local force=""
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
  esac
  [[ "$#" -ge 1 ]] || quit "Usage: $PROGRAM save [--force,-f] PASTA_NAME"
  local pasta_name="$*"
  check_pasta_name "$pasta_name" write $force
  local temp_file
  create_temp_file temp_file
  [[ -f "$temp_file" ]]
  if clipboard_is_image
  then
    $imgpaste > "$temp_file"
    create_pasta_from_file "$temp_file" image "$pasta_name"
  else
    $textpaste > "$temp_file" 2>/dev/null || quit "Error: the clipboard is empty"
    create_pasta_from_file "$temp_file" text "$pasta_name"
  fi
}

pasta_insert() {
  local force=""
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
  esac
  [[ "$#" -ge 1 ]] || quit "Usage: $PROGRAM insert [--force,-f] PASTA_NAME"
  local pasta_name="$*"
  check_pasta_name "$pasta_name" write $force
  local temp_file
  create_temp_file temp_file
  # Remove the temporary file to detect a difference between exiting the
  # editor without doing anything and choosing to write an empty file
  rm "$temp_file"
  ${EDITOR:-vi} "$temp_file"
  [[ -f "$temp_file" ]] || userquit "Pasta not created."
  create_pasta_from_file "$temp_file" text "$pasta_name"
}

pasta_file() {
  local force=""
  case "${1:-}" in
    -f|--force) shift; force="force" ;;
    --) shift ;;
  esac
  [[ $# -ge 2 ]] || quit "Usage: $PROGRAM file [--force,-f] FILE PASTA_NAME"
  local file="$1"
  local pasta_name="${*:2}"
  [[ -f "$file" ]] || { [[ -d "$file" ]] && quit "Error: ${file} is a directory"; } || quit "Error: no file '${file}' exists"
  check_pasta_name "$pasta_name" write $force
  local mimetype="$(file --mime-type -b "$file")"
  local ftype="$(cut -d'/' -f1 <<< "$mimetype")"
  create_pasta_from_file "$file" "$ftype" "$pasta_name" "$mimetype"
}

pasta_load() {
  if [[ "$#" -eq 0 ]]
  then
    pasta_list
    return 0
  fi
  local pasta_name="$*"
  local pasta_type pasta_file
  check_pasta_name "$pasta_name" read pasta_type pasta_file
  pasta_load_file "$pasta_name" "$pasta_type" "$pasta_file"
}

pasta_load_file() {
  local pasta_name="$1"
  local pasta_type="$2"
  local pasta_file="$3"
  case "$pasta_type" in
    dir) pasta_list_dir "$pasta_file" "$pasta_name"; return 0 ;;
    text) $textcopy "$pasta_file" >/dev/null 2>&1 ;;
    image) $imgcopy "$pasta_file" >/dev/null 2>&1 ;;
    *) echoerr "Error: check_pasta_name returned invalid pasta type ${pasta_type}"; exit 1 ;;
  esac
  echo "Loaded ${pasta_type} pasta '${pasta_name}' to the clipboard."
}

pasta_pastefile() {
  not_implemented
}

pasta_show() {
  if [[ "$#" -eq 0 ]]
  then
    pasta_list
    return 0
  fi
  local pasta_name="$*"
  local pasta_type pasta_file
  check_pasta_name "$pasta_name" read pasta_type pasta_file
  case "$pasta_type" in
    dir) pasta_list_dir "$pasta_file" "$pasta_name" ;;
    text) cat "$pasta_file" ;;
    image) $imgshow "$pasta_file" ;;
  esac
}

pasta_list() {
  get_pasta_dir
  local pasta_path="$*"
  check_pasta_name_safety "$*"
  local full_path="${PASTA_DIR}/$pasta_path"
  pasta_list_dir "$full_path" "$pasta_path"
}

pasta_list_dir() {
  local full_path="$1"
  local pasta_name="$2"
  local pasta_path="$(realpath --relative-to="$PASTA_DIR" "$full_path")"
  if [[ -d "$full_path" ]]
  then
    [[ "$pasta_path" == "." ]] && echo Pasta Store || echo "$pasta_path"
  else
    local pasta_type pasta_file
    if check_name_exists "$pasta_path" check pasta_type pasta_file
    then
      [[ "$pasta_type" != "dir" ]] || echoerr "Error: check_name_exists returned dir in pasta_list" && exit 1
      pasta_load_file "$pasta_path" "$pasta_type" "$pasta_file"
      return 0
    else
      quit "Error: ${pasta_name} does not exist"
    fi
  fi

  # Output the tree, removing the root of the tree or the .txt or .png extension but keeping any
  # colors.  Note: this also removes the extension from directories which
  # end an extension, which is a bug. One way to possibly fix this is to
  # detect the color code for directories and check for that, or replace
  # tree with our own implementation.
  tree -C --noreport "$full_path" | tail -n +2 | sed -r 's/\.(txt|png)(\x1b\[00m)?$/\2/'
}

pasta_find() {
  not_implemented
}

pasta_grep() {
  not_implemented
}

pasta_alias() {
  not_implemented
}

pasta_move() {
  not_implemented
}

pasta_delete() {
  not_implemented
}

pasta_edit() {
  not_implemented
}

# END command functions


# BEGIN helper functions

not_implemented() {
  quit "This functionality has not been implemented yet!"
}

echoerr() {
  echo "$@" >&2
}

# Exit with an error message.
quit() {
  echoerr "$@"
  exit 2
}

# Exit with an error message but with the user-cancelled error code.
userquit() {
  echoerr "$@"
  exit 3
}

# Prompt the user for a yes or no question and exit if no.
yesno() {
  local answer
  read -r -p "$1 [yN] " answer
  [[ "$answer" == [yY] ]] || exit 3
}

get_pasta_dir() {
  [[ -f "$PASTA_SETTINGS" ]] || quit "Pasta has not been initialized. Please run:
  $PROGRAM init
before using pasta."
  PASTA_DIR="$(< "$PASTA_SETTINGS")"
  [[ -d "$PASTA_DIR" ]] || quit "Pasta has not been initialized properly. Please run:
  $PROGRAM init"
}

# Usage: check_exists FILE DESCRIPTION
check_exists() {
  [[ ! -f "$1" ]] || yesno "$2 already exists. Overwrite it?"
}

# Usage: check pasta_name_safety PASTA_NAME
check_pasta_name_safety() {
  local name="$1"
  [[ "$name" != ".." ]] && [[ ! "$name" =~ ^"../" ]] && [[ ! "$name" =~ "/.."$ ]] && [[ ! "$name" =~ "/../" ]] || quit "${name} is an invalid pasta name, remove '..' from the name"
}

# Checks if a pasta already exists by name.
# Accepts 3 modes: check, read, and write.
# If read or check is given, it also takes 2 additional arguments TYPE_VAR
# and FILE_VAR, which are the names of the variable to assign the type of
# the pasta and the location of the pasta file. Read exits the program if no
# pasta file exists, while check just returns an error.
# If write is given, it asks the user if they want to overwrite the existing
# pasta, deleting it if they choose yes. However, if the "force" argument is
# given, the answer is assumed to be yes.
# Usage: check_name_exists PASTA_NAME (read|write|check) [ARGS...]
check_name_exists() {
  local pasta_name="$1"
  local operation="$2"
  local pasta_txt_file="${PASTA_DIR}/${pasta_name}.txt"
  local pasta_img_file="${PASTA_DIR}/${pasta_name}.png"
  local pasta_subdir="${PASTA_DIR}/${pasta_name}"
  case "$operation" in
    read|check)
      local type_var="$3"
      local file_var="$4"
      if [[ -f "$pasta_txt_file" ]]
      then
        read "$type_var" "$file_var" <<< "text $pasta_txt_file"
      elif [[ -f "$pasta_img_file" ]]
      then
        read "$type_var" "$file_var" <<< "image $pasta_img_file"
      elif [[ -d "$pasta_subdir" ]]
      then
        read "$type_var" "$file_var" <<< "dir $pasta_subdir"
      elif [[ "$operation" == "read" ]]
      then
        quit "Error: ${pasta_name} does not exist"
      else
        return 1
      fi
      ;;
    write)
      if [[ -f "$pasta_txt_file" ]] || [[ -f "$pasta_img_file" ]]
      then
        local force="${3:-}"
        [[ "$force" == "force" ]] || yesno "${pasta_name} already exists. Overwrite it?"
        rm -f "$pasta_txt_file" "$pasta_img_file"
      fi
      ;;
    *)
      echoerr "check_name_exists called with invalid mode ${read_or_write}"
      exit 1
      ;;
  esac
}

# Boilerplate to verify that a pasta name is valid.
# Usage: check_pasta_name PASTA_NAME read_or_write OPTIONS
check_pasta_name() {
  local pasta_name="$1"
  get_pasta_dir
  check_pasta_name_safety "$pasta_name"
  check_name_exists "$pasta_name" "${@:2}"
}

# Succeeds if the data on the clipboard is an image.
clipboard_is_image() {
  [[ "$SYSTEM" =~ ^Linux ]] && [[ "$(xclip -sel clipboard -o -t TARGETS 2>/dev/null)" =~ image ]]
}

TEMP_FILES=()

# Creates a temp file and saves its name to the given variable.
# Usage: create_temp_file VARIABLE_NAME [EXTENSION]
create_temp_file() {
  local var_name="$1"
  local ext="${2:-}"
  local _temp_file="$(mktemp)"
  if [[ -n "$ext" ]]
  then
    mv "$_temp_file" "${_temp_file}.$ext"
    _temp_file="${_temp_file}.$ext"
  fi
  # Add the current file to the set of tempfiles to delete.
  # This is necessary because only one function can be trapped per signal.
  TEMP_FILES+=("$_temp_file")
  trap "rm -f ${TEMP_FILES[*]}" INT TERM EXIT
  read "$var_name" <<< "$_temp_file"
}

# Ensures the parent directories of a file exists.
# Usage: ensure_parent_dirs FILE
ensure_parent_dirs() {
  mkdir -p "$(dirname "$1")"
}

# Creates a pasta file from an existing file.
# Usage: create_pasta_from_file FILE image_or_text PASTA_NAME [DETECTED_MIME_TYPE]
create_pasta_from_file() {
  local source_file="$1"
  local file_type="$2"
  local pasta_name="$3"
  local pasta_file="${PASTA_DIR}/${pasta_name}"
  # If a previous function already did the work to detect the file type, no need to detect it again.
  local detected_type="${4:-$(file --mime-type -b "$source_file")}"
  if [[ "$detected_type" == "inode/x-empty" ]]
  then
    quit "Error: ${source_file} is empty"
  elif [[ ! "$detected_type" =~ ^text ]] && [[ ! "$detected_type" =~ ^image ]]
  then
    quit "Error: unknown MIME type $detected_type"
  elif [[ ! "$detected_type" =~ ^"$file_type" ]]
  then
    echoerr "Error: given type ${file_type} does not match detected type ${detected_type}"
    exit 1
  fi
  case "$file_type" in
    image)
      pasta_file="${pasta_file}.png"
      # Convert to png if necessary.
      if [[ "$detected_type" != "image/png" ]]
      then
        local temp_png
        create_temp_file temp_png png
        convert "$source_file" "$temp_png"
        source_file="$temp_png"
      fi
      ;;
    text) pasta_file="${pasta_file}.txt" ;;
    # Default case should never be called.
    *) echoerr "Error: unknown declared file type $file_type"; exit 1 ;;
  esac
  # Ensure the parent directory exists.
  ensure_parent_dirs "$pasta_file"
  cp "$source_file" "$pasta_file"
  echo "Saved ${file_type} pasta '${pasta_name}'"
}

# Displays the contents of a pasta.
# Usage: show_pasta_file PASTA_TYPE PASTA_FILE
show_pasta_file() {
  not_implemented
}
# END helper functions

SYSTEM="$(uname -s)"
case "$SYSTEM" in
  Linux*)
    which xclip >/dev/null || quit "Could not find clipboard provider on this system"
    textcopy="xclip -selection clipboard -i"
    textpaste="xclip -selection clipboard -o"
    # Png data seems to work best for pasting into browsers.
    imgcopy="xclip -selection clipboard -t image/png -i"
    imgpaste="xclip -selection clipboard -t image/png -o"
    imgshow="xdg-open"
    ;;
  Darwin*)
    which pbcopy >/dev/null || which pbpaste >/dev/null || quit "Could not find clipboard provider on this system"
    textcopy="pbcopy"
    textpaste="pbpaste"
    imgcopy="quit 'Copying and pasting images is unsupported in MacOS at the moment'"
    imgpaste="quit 'Copying and pasting images is unsupported in MacOS at the moment'"
    imgshow="open"
    ;;
  *)
    quit "pasta is not supported on this system."
esac

PROGRAM="${0##*/}"
COMMAND="${1:-}"
PASTA_SETTINGS="${PASTA_SETTINGS:-"${HOME}/.pasta"}"

case "$COMMAND" in
  init) shift; pasta_init "$@" ;;
  save) shift; pasta_save "$@" ;;
  insert) shift; pasta_insert "$@" ;;
  file) shift; pasta_file "$@" ;;
  load) shift; pasta_load "$@" ;;
  paste) shift; pasta_pastefile "$@" ;;
  show|inspect) shift; pasta_show "$@" ;;
  list|ls) shift; pasta_list "$@" ;;
  find|search) shift; pasta_find "$@" ;;
  grep) shift; pasta_grep "$@" ;;
  alias|ln) shift; pasta_alias "$@" ;;
  cp|rename|mv) shift; pasta_move "$@" ;;
  delete|remove|rm) shift; pasta_delete "$@" ;;
  edit) shift; pasta_edit "$@" ;;
  help|--help|usage) shift; pasta_usage ;;
  version|--version) shift; pasta_version ;;
  *) pasta_load "$@" ;;
esac
exit 0
